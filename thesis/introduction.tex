\chapter{Introduction}
\label{ch:intro}

The main objective of this thesis is to study a variety of orthogonal range searching data structures. \todo{Forts√¶t ligesom Pearson .. side 11}

\emph{Orthogonal range searching} is one of the most fundamental and well-studied problems in computational geometry. Even with extensive research over three decades a lot of questions remain. In this thesis we will focus on $2D$ orthogonal range searching: Given $n$ points from $\mathbb{R}^2$ we want to insert them into a data structure which will be able to efficiently report which $k$ points lie within a given query range $\mathbb{Q} \subseteq \mathbb{R}^2$. This query can be defined as two corners of a rectangle, the lower left corner and the upper right corner, seeing as the query range is orthogonal to the axes. \\

In this thesis we are going to explore data structure we believe to be faster at orthogonal range search than a kd-tree. We are going to introduce the a range reporting data structure by \citet{chanetal}. A simplified version of their data structure will be made and implemented. We wish to show that this simplified version is able to compete with a kd-tree. \\



\noindent \textbf{word-RAM model} The model of computation used in this thesis is the word-RAM model as described by \todo{INSERT REFERENCE}. In the word-RAM model of computation, the memory is divided into words of $\Theta(\lg n)$ bits. Consider points from a universe $U = [1,U]$. The word-RAM model of computation states that a word can fit any point from $U$. This means that the number of bits in a word $w = \Omega(\lg U)$. Given an array $A[1..n]$ the word-RAM model also states that a word can fit any index into $A$. This means that $w = \Omega(\lg n)$. Unless otherwise explicitely expressed, the bounds on the data structures are given in words. Under the word-RAM model all standard word operations take constant time. The possible list of standard word operation from modern programming languages consists of addition, subtraction, multiplication, division and the bit-wise operators. Reading or writing a single word also takes constant time. The number of bits in a word is found by the largest element which has to fit into a word. This means that it is often possible to divide the word into smaller logical blocks which can fit more than one integer. \todo{Rephrase and insert reference} \\


\noindent \textbf{Outline.} Has yet to be written. \\

\noindent \textbf{Notation.} The set of integers $\{i, i+1, \dots, j-1, j\}$ is denoted by $[i,j]$. When no base is explicitely given logarithm will have base $2$. $\epsilon$ is an arbitrary small constant greater than $0$. Given an array $A$, $A[i]$ denotes the entry with index $i$ in $A$ and $A[i,j]$ denotes the subarray containing the entries from $i$ to $j$ in $A$. $A[1..n]$ denotes an array $A$ of size $n$ with entries $1$ to $n$. Throughout the thesis the successor of $x$ in a set will be meant as the first number which is greater or equal to $x$ in that set - the same applies for predecessor of $x$. The work will be done under the assumption that no two points will  have the same x-coordinate and no two points will have the same y-coordinate. This is a unrealistic assumption in practice, but it can easily be remedied by having the points lie in a composite-number space since we only need a total ordering of our points.



