\chapter{Implementation}
\label{ch:implementation}

This chapter will explain some of the choices made as to the implementation of the BIS data structure.

\section{Language}

C++11 was chosen to implement the BIS data structure and the kd-tree. C++11 is a recent release of C++. C++11 combines the advantages of a modern programming language with the stability and support of a mature language which have been around for more than three decades. C++11 was chosen for several reason: It does not have garbage collection, it is a high level language with support for low level operation and contains libraries for everything needed in this project. The chrono header gives access to a high resolution clock to measure time. The vector class of the standard template library is very straight-forward container to work with and the underlying structure is a continuous block of memory making it ideal for cache purposes. The algorithm header gives access to convenience functions for generating and sorting data. The random header gives access to random numbers through a Mersenne twister engine with uniform integer distribution. The random numbers are used to generate the input data for the two data structures, thus giving a different data set every time. The data set is generated by two lists containing the numbers $[0,n-1]$ and using the standard library's shuffle function with the Mersenne twister engine. 

\section{Design choices}

The theory describes the ball inheritance data structure as a binary tree with internal nodes and leaves. Each node has a bit vector representing the ball inheritance. In practice all the bit vectors at each level have been concatenated together to one, resulting in $\lg n$ bit vectors in all. Instead of being an actual entity, a node is just defined as which level it is from, where on that levels list its bit vector starts and how many balls its bit vector holds. Thus, a vector of bit vectors represents the ball inheritance tree. Since each ball only uses a single bit per level there would have been a lot of space wasted when nodes only held two or four balls in their bit vectors. By having a single unified bit vector per level we can pick one data type to work with independent of how many balls needs to be stored per node. The data type chosen is an unsigned fixed width integer type of $32$ bits. \\

We are going to describe how to support constant-time succinct rank queries for a unified bit vector. First a checkpoint is added to every 32nd entry storing the amount of $1$s seen in the bit vector so far. Since the bit vectors consist of entries of either $0$ and $1$ we only need count the amount of $1$s. The rank of an entry with index $i$ storing a $1$ bit is exactly the amount of $1$s between index $1$\footnote{Arrays are $1$-based} and $i$. The rank of an entry with index $i$ storing a $0$ bit is $i$ subtracted by the amount of $1$s between index $1$ and $i$. This is because we know that an entry not storing a $1$ bit must be storing a $0$ bit. A table is computed which given a $16$ bit unsigned integer is able to answer how many $1$ are in the binary representation of the integer. The table is a flat array and supports look-up in constant time.

Given a position $i$ in the bit vector, the closest checkpoint previous to $i$ is found. The data type storing the bits in the bit vector is a $32$ bit unsigned integer. We can thus only retrieve data from the bit vector in blocks of $32$ bits. We use a \emph{binary and} to mask away the bits after $i$ and divide the $32$ integer into two $16$ bits integers. Using the precomputed table from before, we look up how many $1$s the binary representation of the two $16$ bit integer contain. The sum of the major checkpoint and the two table look-ups is the amount of times a $1$ occurs before position $i$ in the bit vector. 

However, we are seldom interested in knowing how many $1$s there are in a bit vector between position $1$ and $i$. We want to know how many $1$s there are between $j$ and $i$, where $j$ is the start position of a node and $i$ is an entry in that node. We know that with the ball inheritance structure, each node gives each of its children half of its balls. Thus, half of the entries in the bit vector of a node are $1$s. And thus, if $j$ is the start position of a node in the unified bit vector, there will be $\frac{j}{2}$ entries in the bit vector between $1$ and $j$ which are $1$s. Since one of the ingredients for a virtual node is the start position in the unified bit vector, we already know $j$ when looking up the rank of $i$. Using the unified bit vectors instead of an actual tree then poses no problems.

The source code for the BIS data structure will be made available online at http://www.madsravn.dk/BIS.

\todo{Index vs position}
